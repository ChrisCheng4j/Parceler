package com.chrischeng.parceler.compiler.generator;

import com.chrischeng.parceler.compiler.ParcelConstants;
import com.chrischeng.parceler.compiler.exception.ParcelerInternalException;
import com.chrischeng.parceler.compiler.model.ParcelArgFieldInfo;
import com.chrischeng.parceler.compiler.util.CompileTools;
import com.chrischeng.parceler.compiler.util.TextUtils;
import com.squareup.javapoet.ClassName;
import com.squareup.javapoet.CodeBlock;
import com.squareup.javapoet.JavaFile;
import com.squareup.javapoet.MethodSpec;
import com.squareup.javapoet.ParameterSpec;
import com.squareup.javapoet.ParameterizedTypeName;
import com.squareup.javapoet.TypeName;
import com.squareup.javapoet.TypeSpec;

import java.io.IOException;
import java.util.List;
import java.util.Map;
import java.util.Set;

import javax.lang.model.element.Element;
import javax.lang.model.element.ElementKind;
import javax.lang.model.element.ExecutableElement;
import javax.lang.model.element.Modifier;
import javax.lang.model.element.PackageElement;
import javax.lang.model.element.TypeElement;

public class ParcelArgCodeGenerator {

    private static String methodName;
    private static String parentInjectFormat;

    public static void generate(Map<TypeElement, List<ParcelArgFieldInfo>> args) throws IOException {
        if (args == null || args.isEmpty())
            return;

        Set<TypeElement> typeElements = args.keySet();
        for (TypeElement typeElement : typeElements) {
            TypeSpec.Builder typeBuilder = TypeSpec.classBuilder(getClassSimpleName(typeElement))
                    .addModifiers(Modifier.PUBLIC, Modifier.FINAL)
                    .addSuperinterface(ParameterizedTypeName.get(ClassName.get(ParcelConstants.PACKAGE_NAME, ParcelConstants.INTERFACE_ARG_INJECTOR_SIMPLE_NAME), ClassName.get(typeElement)));
            typeBuilder.addMethod(generateInjectMethod(typeElement, args.get(typeElement)));

            JavaFile.builder(getPackageName(typeElement), typeBuilder.build())
                    .addFileComment("This class is generated by Parceler. Do not modify!")
                    .build()
                    .writeTo(CompileTools.get().getFiler());
        }
    }

    private static String getClassSimpleName(TypeElement typeElement) {
        return typeElement.getSimpleName() + ParcelConstants.GENERATE_CLASS_ARG_INJECTOR_SUFFIX_NAME;
    }

    private static MethodSpec generateInjectMethod(TypeElement typeElement, List<ParcelArgFieldInfo> fieldInfos) {
        ClassName typeClassName = ClassName.get(typeElement);
        ClassName parcelerClassName = ClassName.get(ParcelConstants.PACKAGE_NAME, ParcelConstants.CLASS_PARCELER_SIMPLE_NAME);

        MethodSpec.Builder methodBuilder = MethodSpec.methodBuilder(ParcelConstants.GENERATE_METHOD_INJECT_NAME)
                .addAnnotation(Override.class)
                .addModifiers(Modifier.PUBLIC)
                .addParameter(ParameterSpec.builder(typeClassName, ParcelConstants.PARAM_TARGET_NAME).build())
                .addParameter(ParameterSpec.builder(ClassName.get("android.os", "Bundle"), ParcelConstants.PARAM_BUNDLE_NAME).build())
                .returns(TypeName.VOID);

        TypeElement interfaceElement = CompileTools.get().getElementUtils().getTypeElement(ParcelConstants.INTERCE_ARG_INJECTOR_FULL_NAME);
        ExecutableElement executableElement = getOverrideMethod(interfaceElement, ParcelConstants.GENERATE_METHOD_INJECT_NAME);

        if (TextUtils.isEmpty(methodName))
            methodName = executableElement.getSimpleName().toString();

        methodBuilder.addStatement("$T injector = $T." + ParcelConstants.METHOD_PARENT_INJECTOR_NAME + "($T.class)",
                ClassName.get(ParcelConstants.PACKAGE_NAME, ParcelConstants.INTERFACE_ARG_INJECTOR_SIMPLE_NAME),
                parcelerClassName,
                typeClassName);

        methodBuilder.beginControlFlow("if (injector != null)");
        if (TextUtils.isEmpty(parentInjectFormat))
            parentInjectFormat = "$T." + ParcelConstants.METHOD_PARENT_INJECTOR_NAME + "($T.class)" + "." + methodName + getMethodParamsFormat();
        methodBuilder.addStatement(parentInjectFormat, parcelerClassName, typeClassName);
        methodBuilder.endControlFlow();

        CodeBlock newLineblock = CodeBlock.builder().add("\r\n").build();
        methodBuilder.addCode(newLineblock);

        methodBuilder.addStatement("Object obj");

        StringBuilder statementFormat;
        for (ParcelArgFieldInfo fieldInfo : fieldInfos) {
            methodBuilder.addCode(newLineblock);

            methodBuilder.addStatement("obj = " + ParcelConstants.PARAM_BUNDLE_NAME + "." + ParcelConstants.METHOD_BUNDLE_GET_NAME + "($S)", fieldInfo.key);

            methodBuilder.beginControlFlow("if (obj != null)");

            statementFormat = new StringBuilder();
            statementFormat.append(ParcelConstants.PARAM_TARGET_NAME + "." + fieldInfo.name);
            statementFormat.append(" = ");
            statementFormat.append("(" + "$T" + ") ");
            statementFormat.append("obj");
            methodBuilder.addStatement(statementFormat.toString(), fieldInfo.typeMirror);

            methodBuilder.endControlFlow();
        }

        return methodBuilder.build();
    }

    private static ExecutableElement getOverrideMethod(TypeElement typeElement, String methodName) {
        if (typeElement != null) {
            List<? extends Element> enclosedElement = typeElement.getEnclosedElements();
            if (enclosedElement != null && !enclosedElement.isEmpty()) {
                for (Element element : enclosedElement) {
                    if (element.getKind() != ElementKind.METHOD || !element.getSimpleName().toString().equals(methodName))
                        continue;

                    return (ExecutableElement) element;
                }
            }
        }

        throw new ParcelerInternalException(String.format("Could not found method %s when getOverrideMethod during generate code.", methodName));
    }

    private static String getMethodParamsFormat() {
        return "(" + ParcelConstants.PARAM_TARGET_NAME + ", " + ParcelConstants.PARAM_BUNDLE_NAME + ")";
    }

    private static String getPackageName(TypeElement typeElement) {
        Element element = typeElement.getEnclosingElement();
        if (element.getKind() == ElementKind.PACKAGE)
            return ((PackageElement) element).getQualifiedName().toString();

        return getPackageName((TypeElement) element);
    }
}
